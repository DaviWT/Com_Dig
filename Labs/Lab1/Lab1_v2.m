%% Lab1.m
%
%   Authors: Adriano Ricardo de Abreu Gamba
%            Davi Wei Tokikawa
%   
%   Subject: Comunicações Digitais
%   
%   Date: 08/2019
%   
%   Description: This script simulates a digital communication system,
%   where a known message is sent and then is received, decoded and
%   comparated with the initial message. The main objective was to
%   implement the best way to eliminate the gaussian noise in order to
%   improve the receiving. To do that, we use a butterworth filter with fc
%   about equal to the biggest main frequêncy of the message.
%   

%% Initing code
tic
close all
clear
warning off
BER_ap = [];
BER_ort = [];
energy = [];
fprintf('Begin!\n');

% Doing the process to different values of amplitude
for AMP=1:2:35   
    fprintf('Doing for Antipodal and AMP = %i\n',AMP);
    energy = cat(2, energy, AMP);
    
    %% Exemplo Antipodal
    % Waveform parameters
    Fs = 100;
    Ts = 1;
    N = 100000;

    % bits definition
    bit1=ones(1,Fs);
    bit0=-ones(1,Fs);
    
    % Generating random symbols
    y=zeros(1,N*Fs);   % Holds the random generated symbols
    inBits1=zeros(1,N); % Holds the initial code message
    for i=1:N
        num = randint;
        inBits1(i) = num;
        if num==1
            y((1+(i-1)*100):100*i) = bit1;
        else
            y((1+(i-1)*100):100*i) = bit0;
        end
    end
    y=AMP.*y;
    rec = y;
    t=0:1/Fs:N-1/Fs;
    
%     % Plot the message
%     figure
%     plot(t,y);
%     xlabel('tempo (s)');
%     axis([0 N -2*AMP 2*AMP])
    
    % Plot the message on frequency
    %figure;
    %plot(abs(fft(y)));

    % Insert noise on the message
    ruido = randn(1,length(y))*sqrt(100); %Potencia do ruido=100
    y = y + ruido;

%     % Plot message with noite
%     figure
%     t=0:1/Fs:N-1/Fs;
%     plot(t,y)
%     xlabel('tempo (s)');
%     axis([0 N -10 10])

    %% Detecção do sinal antipodal
    
    % Plot the message on frequency
    %figure;
    %plot(abs(fft(y)));
    
    % Filter
    fc = 10;
    [B,A] = butter(10,fc/(Fs/2));
    out = filter(B,A,y);
    
%     % Plot message before and after the filter
%     figure
%     plot(t,rec);
%     hold on;
%     plot(t,out,'r');

    % Decision making to generate the received message
    outBits1=[]; % Hold the received message
    for i = 1:N
        bitX = out(1+((i-1)*100):i*100); % Hold the current symbol
        if bitX(50)>=0
            outBits1=cat(2, outBits1, 1);
        else
            outBits1=cat(2, outBits1, 0);
        end
    end
    
    % Compares the messages before and after the system and then registers
    % the calculated BER in order to generate a BER array with the values
    % generated by different amplitudes
    xBits = (inBits1==outBits1);
    xBits = (xBits==0);
    xBits = sum(xBits); % Get number of error bits
    BER_ap = cat(2,BER_ap,xBits/N); % Register the BER values
    
    %% Exemplo Ortogonal
    fprintf('Doing for Ortogonal and AMP = %i\n',AMP);
    
    % bits definition
    bit1=ones(1,Fs);
    bit0=[ones(1,Fs/2) -ones(1,Fs/2)];
    
    % Generating random symbols
    y = zeros(1,N*Fs);   % Holds the random generated symbols
    inBits2 = zeros(1,N); % Holds the initial code message
    for i=1:N
        num = randint;
        inBits2(i) = num;
        if num==1
            y((1+(i-1)*100):100*i) = bit1;
        else
            y((1+(i-1)*100):100*i) = bit0;
        end
    end
    y=AMP.*y;
    rec = y;
    t=0:1/Fs:N-1/Fs;

%     % Plot the message
%     figure
%     plot(t,y)
%     xlabel('tempo (s)');
%     axis([0 N -2*AMP 2*AMP])

    % Insert noise on the message
    ruido = randn(1,length(y))*sqrt(100); %Potencia do ruido=100
    y = y + ruido;

%     % Plot message with noite
%     figure
%     t=0:1/Fs:N-1/Fs;
%     plot(t,y)
%     xlabel('tempo (s)');
%     axis([0 N -10 10])

    %% Detecção do sinal ortogonal
    
    % Plot the message on frequency
    %figure;
    %plot(abs(fft(y)));

    % Filter
    fc = 20;
    [B,A] = butter(10,fc/(Fs/2));
    out = filter(B,A,y);
    
%     % Plot message before and after the filter
%     figure
%     plot(t,rec);
%     hold on;
%     plot(t,out,'r');
    
    % Decision making to generate the received message
    outBits2=[]; % Hold the received message signal
    for i = 1:N
        bitX = out(1+((i-1)*100):i*100); % Hold the code message
        if bitX(25)>0 && bitX(75)>0
            outBits2=cat(2, outBits2, 1);
        else
            outBits2=cat(2, outBits2, 0);
        end
    end
    
    % Compares the messages before and after the system and then registers
    % the calculated BER in order to generate a BER array with the values
    % generated by different amplitudes
    xBits = (inBits2==outBits2);
    xBits = xBits==0;
    xBits = sum(xBits);
    BER_ort=cat(2,BER_ort,xBits/N);
end

% Generating plot with the energy and the BER values
figure;
plot(energy,BER_ap);
hold on;
plot(energy,BER_ort,'r');
fprintf('Done!\n');
toc